import {
  require_typeof
} from "./chunk-3FFQX3XX.js";
import {
  __commonJS
} from "./chunk-J43GMYXM.js";

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/emoji-mart/dist/utils/data.js
var require_data = __commonJS({
  "node_modules/emoji-mart/dist/utils/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.uncompress = exports.compress = exports.buildSearch = void 0;
    var mapping = {
      name: "a",
      unified: "b",
      non_qualified: "c",
      has_img_apple: "d",
      has_img_google: "e",
      has_img_twitter: "f",
      has_img_facebook: "h",
      keywords: "j",
      sheet: "k",
      emoticons: "l",
      text: "m",
      short_names: "n",
      added_in: "o"
    };
    var buildSearch = function buildSearch2(emoji) {
      var search = [];
      var addToSearch = function addToSearch2(strings, split) {
        if (!strings) {
          return;
        }
        ;
        (Array.isArray(strings) ? strings : [strings]).forEach(function(string) {
          ;
          (split ? string.split(/[-|_|\s]+/) : [string]).forEach(function(s) {
            s = s.toLowerCase();
            if (search.indexOf(s) == -1) {
              search.push(s);
            }
          });
        });
      };
      addToSearch(emoji.short_names, true);
      addToSearch(emoji.name, true);
      addToSearch(emoji.keywords, false);
      addToSearch(emoji.emoticons, false);
      return search.join(",");
    };
    exports.buildSearch = buildSearch;
    var compress = function compress2(emoji) {
      emoji.short_names = emoji.short_names.filter(function(short_name) {
        return short_name !== emoji.short_name;
      });
      delete emoji.short_name;
      emoji.sheet = [emoji.sheet_x, emoji.sheet_y];
      delete emoji.sheet_x;
      delete emoji.sheet_y;
      emoji.added_in = parseInt(emoji.added_in);
      if (emoji.added_in === 6) {
        delete emoji.added_in;
      }
      for (var key in mapping) {
        emoji[mapping[key]] = emoji[key];
        delete emoji[key];
      }
      for (var _key in emoji) {
        var value = emoji[_key];
        if (Array.isArray(value) && !value.length) {
          delete emoji[_key];
        } else if (typeof value === "string" && !value.length) {
          delete emoji[_key];
        } else if (value === null) {
          delete emoji[_key];
        }
      }
    };
    exports.compress = compress;
    var uncompress = function uncompress2(data) {
      data.compressed = false;
      for (var id in data.emojis) {
        var emoji = data.emojis[id];
        for (var key in mapping) {
          emoji[key] = emoji[mapping[key]];
          delete emoji[mapping[key]];
        }
        if (!emoji.short_names)
          emoji.short_names = [];
        emoji.short_names.unshift(id);
        emoji.sheet_x = emoji.sheet[0];
        emoji.sheet_y = emoji.sheet[1];
        delete emoji.sheet;
        if (!emoji.text)
          emoji.text = "";
        if (!emoji.added_in)
          emoji.added_in = 6;
        emoji.added_in = emoji.added_in.toFixed(1);
        emoji.search = buildSearch(emoji);
      }
    };
    exports.uncompress = uncompress;
  }
});

// node_modules/emoji-mart/dist/polyfills/stringFromCodePoint.js
var require_stringFromCodePoint = __commonJS({
  "node_modules/emoji-mart/dist/polyfills/stringFromCodePoint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _String = String;
    var _default = _String.fromCodePoint || function stringFromCodePoint() {
      var MAX_SIZE = 16384;
      var codeUnits = [];
      var highSurrogate;
      var lowSurrogate;
      var index = -1;
      var length = arguments.length;
      if (!length) {
        return "";
      }
      var result = "";
      while (++index < length) {
        var codePoint = Number(arguments[index]);
        if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || Math.floor(codePoint) != codePoint) {
          throw RangeError("Invalid code point: " + codePoint);
        }
        if (codePoint <= 65535) {
          codeUnits.push(codePoint);
        } else {
          codePoint -= 65536;
          highSurrogate = (codePoint >> 10) + 55296;
          lowSurrogate = codePoint % 1024 + 56320;
          codeUnits.push(highSurrogate, lowSurrogate);
        }
        if (index + 1 === length || codeUnits.length > MAX_SIZE) {
          result += String.fromCharCode.apply(null, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result;
    };
    exports["default"] = _default;
  }
});

// node_modules/emoji-mart/dist/utils/index.js
var require_utils = __commonJS({
  "node_modules/emoji-mart/dist/utils/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getData = getData;
    exports.getEmojiDataFromNative = getEmojiDataFromNative;
    exports.getSanitizedData = getSanitizedData;
    exports.uniq = uniq;
    exports.intersect = intersect;
    exports.deepMerge = deepMerge;
    exports.unifiedToNative = unifiedToNative;
    exports.measureScrollbar = measureScrollbar;
    exports.throttleIdleTask = throttleIdleTask;
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _data = require_data();
    var _stringFromCodePoint = _interopRequireDefault(require_stringFromCodePoint());
    var COLONS_REGEX = /^(?:\:([^\:]+)\:)(?:\:skin-tone-(\d)\:)?$/;
    var SKINS = ["1F3FA", "1F3FB", "1F3FC", "1F3FD", "1F3FE", "1F3FF"];
    function unifiedToNative(unified) {
      var unicodes = unified.split("-"), codePoints = unicodes.map(function(u) {
        return "0x".concat(u);
      });
      return _stringFromCodePoint["default"].apply(null, codePoints);
    }
    function sanitize(emoji) {
      var name = emoji.name, short_names = emoji.short_names, skin_tone = emoji.skin_tone, skin_variations = emoji.skin_variations, emoticons = emoji.emoticons, unified = emoji.unified, custom = emoji.custom, customCategory = emoji.customCategory, imageUrl = emoji.imageUrl, id = emoji.id || short_names[0], colons = ":".concat(id, ":");
      if (custom) {
        return {
          id,
          name,
          short_names,
          colons,
          emoticons,
          custom,
          customCategory,
          imageUrl
        };
      }
      if (skin_tone) {
        colons += ":skin-tone-".concat(skin_tone, ":");
      }
      return {
        id,
        name,
        short_names,
        colons,
        emoticons,
        unified: unified.toLowerCase(),
        skin: skin_tone || (skin_variations ? 1 : null),
        "native": unifiedToNative(unified)
      };
    }
    function getSanitizedData() {
      return sanitize(getData.apply(void 0, arguments));
    }
    function getData(emoji, skin, set, data) {
      var emojiData = {};
      if (typeof emoji == "string") {
        var matches = emoji.match(COLONS_REGEX);
        if (matches) {
          emoji = matches[1];
          if (matches[2]) {
            skin = parseInt(matches[2], 10);
          }
        }
        if (data.aliases.hasOwnProperty(emoji)) {
          emoji = data.aliases[emoji];
        }
        if (data.emojis.hasOwnProperty(emoji)) {
          emojiData = data.emojis[emoji];
        } else {
          return null;
        }
      } else if (emoji.id) {
        if (data.aliases.hasOwnProperty(emoji.id)) {
          emoji.id = data.aliases[emoji.id];
        }
        if (data.emojis.hasOwnProperty(emoji.id)) {
          emojiData = data.emojis[emoji.id];
          skin || (skin = emoji.skin);
        }
      }
      if (!Object.keys(emojiData).length) {
        emojiData = emoji;
        emojiData.custom = true;
        if (!emojiData.search) {
          emojiData.search = (0, _data.buildSearch)(emoji);
        }
      }
      emojiData.emoticons || (emojiData.emoticons = []);
      emojiData.variations || (emojiData.variations = []);
      if (emojiData.skin_variations && skin > 1) {
        emojiData = JSON.parse(JSON.stringify(emojiData));
        var skinKey = SKINS[skin - 1], variationData = emojiData.skin_variations[skinKey];
        if (variationData) {
          if (!variationData.variations && emojiData.variations) {
            delete emojiData.variations;
          }
          if (set && (variationData["has_img_".concat(set)] == void 0 || variationData["has_img_".concat(set)]) || !set) {
            emojiData.skin_tone = skin;
            for (var k in variationData) {
              var v = variationData[k];
              emojiData[k] = v;
            }
          }
        }
      }
      if (emojiData.variations && emojiData.variations.length) {
        emojiData = JSON.parse(JSON.stringify(emojiData));
        emojiData.unified = emojiData.variations.shift();
      }
      return emojiData;
    }
    function getEmojiDataFromNative(nativeString, set, data) {
      if (data.compressed) {
        (0, _data.uncompress)(data);
      }
      var skinTones = ["\u{1F3FB}", "\u{1F3FC}", "\u{1F3FD}", "\u{1F3FE}", "\u{1F3FF}"];
      var skinCodes = ["1F3FB", "1F3FC", "1F3FD", "1F3FE", "1F3FF"];
      var skin;
      var skinCode;
      var baseNativeString = nativeString;
      skinTones.forEach(function(skinTone, skinToneIndex) {
        if (nativeString.indexOf(skinTone) > 0) {
          skin = skinToneIndex + 2;
          skinCode = skinCodes[skinToneIndex];
        }
      });
      var emojiData;
      for (var id in data.emojis) {
        var emoji = data.emojis[id];
        var emojiUnified = emoji.unified;
        if (emoji.variations && emoji.variations.length) {
          emojiUnified = emoji.variations.shift();
        }
        if (skin && emoji.skin_variations && emoji.skin_variations[skinCode]) {
          emojiUnified = emoji.skin_variations[skinCode].unified;
        }
        if (unifiedToNative(emojiUnified) === baseNativeString)
          emojiData = emoji;
      }
      if (!emojiData) {
        return null;
      }
      emojiData.id = emojiData.short_names[0];
      return getSanitizedData(emojiData, skin, set, data);
    }
    function uniq(arr) {
      return arr.reduce(function(acc, item) {
        if (acc.indexOf(item) === -1) {
          acc.push(item);
        }
        return acc;
      }, []);
    }
    function intersect(a, b) {
      var uniqA = uniq(a);
      var uniqB = uniq(b);
      return uniqA.filter(function(item) {
        return uniqB.indexOf(item) >= 0;
      });
    }
    function deepMerge(a, b) {
      var o = {};
      for (var key in a) {
        var originalValue = a[key], value = originalValue;
        if (b.hasOwnProperty(key)) {
          value = b[key];
        }
        if ((0, _typeof2["default"])(value) === "object") {
          value = deepMerge(originalValue, value);
        }
        o[key] = value;
      }
      return o;
    }
    function measureScrollbar() {
      if (typeof document == "undefined")
        return 0;
      var div = document.createElement("div");
      div.style.width = "100px";
      div.style.height = "100px";
      div.style.overflow = "scroll";
      div.style.position = "absolute";
      div.style.top = "-9999px";
      document.body.appendChild(div);
      var scrollbarWidth = div.offsetWidth - div.clientWidth;
      document.body.removeChild(div);
      return scrollbarWidth;
    }
    function throttleIdleTask(func) {
      var doIdleTask = typeof requestIdleCallback === "function" ? requestIdleCallback : setTimeout;
      var running = false;
      return function throttled() {
        if (running) {
          return;
        }
        running = true;
        doIdleTask(function() {
          running = false;
          func();
        });
      };
    }
  }
});

export {
  require_interopRequireDefault,
  require_data,
  require_utils
};
//# sourceMappingURL=chunk-EZE2A3BV.js.map
